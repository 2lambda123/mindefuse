#!/usr/bin/env python3.7

from functools import partial
from itertools import product, tee
from collections import defaultdict
from multiprocessing import Pool

from ..strategy import Strategy
from mindefuse.problem import Problem
from ..strategy_types import StrategyTypes
from .knuth_config import KnuthConfig as Config


class KnuthStrategy(Strategy):
    """
    Knuth algorithm strategy.
    Given the number of possible elements of the secret C, and the size of the secret sequence, S,
    1. Create a set S, the solution space, and a set A, all the unused codes, from the set of all possible codes, C^S.
    2. Generate an initial guess.
    3. Play the guess, G, and obtain the corresponding value of whites and reds.
    4. Verify if the game is over,
        if the maximum number of rounds has passed or
        if number of reds is equal to the size of the secret, if it is, the game is won.
    5. Remove G from S and from A.
    6. Otherwise, prune from S any code that would not give the same response if it was the secret sequence.
    7. Apply minimax to find the set of next possible guesses,
    For each code in A, calculate how many possibilities in S would be eliminated for each possible white+red peg score.
    The score of a code is the minimum number of possibilities it might eliminate from S.
    The best scores, are the lowest ones, since they assure that, in the worst case, the solution space gets as
    narrowed down as possible.
    Thus, the set of guesses is created with the minimum max scored sequences, B.
    8. Choose the next guess G, from B, by selecting, if possible, the lowest value also present in S, otherwise from A.
    9. Repeat from step 3.
    """

    """strategy identification type"""
    _type = StrategyTypes.KNUTH

    @staticmethod
    def _initial_guess(problem):
        """
        Generates the first guess to use as input.
        Knuth's initial guess was '1122', which in our definition of 'numeric' would be '0011'.
        Considering a similar approach, our guess will be generated by using the first available element twice,
        and subsequent elements plus one, then crop the value to match the required size.
        :param problem: problem to which the guess will be submitted
        :return: sequence to use as the first guess
        """
        secret_size = problem.secret_size()
        possible_elements = problem.possible_elements()

        return "".join(time * el for time, el in zip(range(2, secret_size + 1), possible_elements))[:secret_size]

    @staticmethod
    def _generate_combinations(possible_elements, sequence_size):
        """
        Generates all possible combinations of elements with a given sequence size
        :param possible_elements: elements used to create the sequence
        :param sequence_size: size of the sequence to create
        :return: all possible combinations
        """
        return map(''.join, product(possible_elements, repeat=sequence_size))

    @staticmethod
    def _get_next_guess(guesses, all_combinations, solutions):
        """
        Chooses the next guess from the set of minimum max scored guesses
        :param guesses: guesses to choose from
        :param all_combinations: all available combinations
        :param solutions: current solution space
        :return: next guess
        """
        solutions = set(solutions)

        guesses1, guesses2 = tee(guesses)

        for guess in guesses1:
            if guess in solutions:
                return guess

        all_combinations = set((comb for comb in all_combinations if comb not in solutions))

        for guess in guesses2:
            if guess in all_combinations:
                return guess

    @staticmethod
    def _remove_guess(guesses, guess_to_remove):
        """
        Provide the list of guesses after removing another guess
        :param guesses: guesses
        :param guess_to_remove: guess to remove
        :return: guesses without the removed element
        """
        return (guess for guess in guesses if guess != guess_to_remove)

    @staticmethod
    def _prune_guesses(guesses, last_guess, answer):
        """
        Provides guesses after pruning all the sequences that would not provide the same response.
        :param guesses: guesses to be pruned
        :param last_guess: last sequence proposed as a solution
        :param answer: response to last_guess
        :return: pruned guesses
        """
        return (guess for guess in guesses if Problem.compare_sequences(guess, last_guess) == answer)

    @staticmethod
    def _count_score(combination, solutions):
        """
        Provides the
        Sets in scores the score of the provided combination.
        The score of a combination is the maximum size of the solution space, in the worst case,
        if the said combination was the secret sequence.
        :param combination: combination being tested
        :param solutions: solution space
        """
        score_count = defaultdict(int)

        for solution in solutions:
            score = sum(Problem.compare_sequences(combination, solution))  # sum the two elements of the array
            score_count[score] += 1

        return combination, score_count[max(score_count, key=score_count.get)]

    def _mini_max(self, combinations, solutions):
        """
        Provide the list of minimum max scored sequences for the problem.
        :param combinations: all available combinations
        :param solutions: solution space
        :return: the minimum max scored guesses
        """

        pool = Pool(Config.POOL_SIZE)
        combinations_space = list(combinations)

        scores = {
            combinations: score for combinations, score in pool.imap_unordered(
                    partial(self._count_score, solutions=list(solutions)),
                    iterable=combinations_space,
                    chunksize=len(combinations_space) // Config.POOL_SIZE,
            )
        }

        pool.close()

        # minimum max score
        min_score = min(scores.values())

        # filter the sequences with the minimum max score
        next_guesses = sorted((k for k, v in scores.items() if v == min_score))

        return next_guesses

    def solve_problem(self, problem):
        """
        Solves a problem using Knuth algorithm
        :param problem: problem to solve
        :return: problem after running the algorithm
        """
        secret_size = problem.secret_size()
        possible_elements = problem.possible_elements()

        current_guess = self._initial_guess(problem)

        proposal = self.create_proposal(current_guess)

        answer = problem.check_proposal(proposal)

        solutions = self._generate_combinations(possible_elements, secret_size)
        all_combinations = self._generate_combinations(possible_elements, secret_size)

        while not problem.finished():

            # remove guess from pools
            solutions = self._remove_guess(solutions, current_guess)
            all_combinations = self._remove_guess(all_combinations, current_guess)

            # remove from solutions any code that would not give the same response if it was the secret sequence
            solutions = self._prune_guesses(solutions, current_guess, (answer.whites, answer.reds))

            solutions, solutions_aux = tee(solutions)
            all_combinations, all_combinations_aux = tee(all_combinations)
            next_guesses = self._mini_max(all_combinations_aux, solutions_aux)

            solutions, solutions_aux = tee(solutions)
            all_combinations, all_combinations_aux = tee(all_combinations)
            current_guess = self._get_next_guess(next_guesses, all_combinations_aux, solutions_aux)

            proposal = self.create_proposal(current_guess)

            answer = problem.check_proposal(proposal)

        problem.print_history()
        return problem
